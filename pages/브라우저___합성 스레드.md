date-created:: [[2026-01-30]]
date-modified:: [[2026-01-30]]
division:: [[makr]]
stack:: frontend, browser-engine
tags:: browser, compositor-thread, rendering, scrolling
type:: 
alias:: browser/compositor thread
public:: true
status:: [[ai-proofed]]

- ## Summary
	- 브라우저에서 화면 구성 요소의 연산과 출력은 메인 스레드와 합성 스레드가 각각 역할을 분담한다.
	- 특히 `transform`, `opacity` 속성이 성능 최적화에 유리한 이유가 합성 스레드에서 직접 처리되기 때문임을 파악함.
- ## Steps
	- 브라우저는 효율적인 화면 렌더링을 위해 아래와 같이 업무를 분담한다.
	- | 구분 | 메인 스레드 (Main Thread) | 합성 스레드 (Compositor Thread) |
	  | **역할** | 자바스크립트 실행, HTML/CSS 파싱, 레이아웃 계산(Layout), 페인트(Paint) | **레이어 조립**, 화면 출력, **스크롤 처리**, GPU 통신 |
	  | **특징** | 비즈니스 로직을 처리하느라 자주 바쁨 (싱글 스레드) | 메인 스레드와 독립적으로 작동하여 **절대 멈추지 않음** |
	  | **비유** | 요리사 (재료 손질, 레시피 해석, 실제 조리) | 서빙 매니저 (완성된 접시를 쟁반에 담아 손님에게 전달) |
	- 합성 스레드의 작업 단계
		- 브라우저가 화면을 그릴 때, 전체 페이지를 통째로 하나로 그리지 않는다.
		- 포토샵의 레이어처럼 페이지를 여러 개의 **레이어(Layer)**로 나눈다.
			- **페인팅(Paint)**: 메인 스레드가 각 레이어의 내용을 그린다. (예: 배경 레이어, 버튼 레이어, 고정 바 레이어)
			- **타일링(Tiling)**: 그려진 레이어를 작은 타일 단위로 쪼개 메모리를 절약한다.
			- **합성(Compositing)**: 합성 스레드가 이 레이어들을 순서대로 겹치고 좌표를 계산하여 GPU에게 전달한다.
- ## Troubleshooting
	- 메인 스레드와 합성 스레드 사이의 처리 시간 차이로 인한 상태 불일치
		- 원인
			- 합성 스레드가 이동시킨 **화면의 특정 지점**과 메인 스레드가 뒤늦게 처리한 **해당 지점의 콘텐츠 상태(애니메이션 등)** 사이에 시차가 발생하는 경우가 있다.
			- 사용자는 이 시차를 통해 콘텐츠가 스크롤을 못 따라오고 덜덜거리는 **렉(Lag)** 혹은 지연 현상으로 인식할 수 있다.
		- 해결책
			- 합성 스레드에서 처리할 화면 이동 좌표를 가로채 메인 스레드의 연산과 부합하는 좌표로 화면을 강제로 이동시킨다. 이는 Lenis로 처리한다.
			- 메인 스레드에서 지연이 발생하는 경우, 현재 시간(브라우저에서 해당 페이지를 호출한 시점부터 계산하는 브라우저 내부 시간)예 해당하는 상태로 애니메이션을 진행시켜 합성 스레드가 연산한 화면 이동 좌표와 애니메이션을 동기화한다.  GSAP에서 lagSmoothing으로 처리한다.
			- 브라우저의 Repaint 연산 최소화
				- 스크롤 애니메이션이 transform이나 opacity 상태를 변경할 경우 합성 스레드가 다시 그리기 없이 레이어 조립 위치만 바꾸면 되기 때문에 메인 스레드를 거치지 않고 합성 스레드에서 신속하게 처리할 수 있다.
- ## log
	- [[2026-01-30]] Page created.
- ### References
	- [[lenis, GSAP]]