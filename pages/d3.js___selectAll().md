## 개요
	- 매개변수로 받은 요소를 DOM에서 선택해 이를 반환한다.
		- DOM 요소를 선택한다. 선택된 요소에 다양한 방법으로 처리할 수 있도록 돕는다.
		  logseq.order-list-type:: number
		- 선택하고자 하는 요소를 찾아서 선택하는 절차적 로직이다. 선택하려는 요소의 유무에 따라 실행 로직이 달라지는 분기형 로직이 아님에 유의해야 한다.
		  logseq.order-list-type:: number
			- logseq.order-list-type:: number
			  ```js
			  // 의사 코드로 본 d3.selectAll() 내부
			  function selectAll(selector) {
			      const elements = document.querySelectorAll(selector);
			      
			      // 요소가 0개든, 100개든 이 코드는 동일하게 실행됨
			      return new Selection(elements); // 항상 Selection 객체 반환
			  }
			  ```
			- 선택하고자 하는 요소가 있을 때:
			  logseq.order-list-type:: number
				- `querySelectorAll()` 실행 → NodeList 반환
				  logseq.order-list-type:: number
				- `new Selection([element1, element2, ...])` 생성
				  logseq.order-list-type:: number
				- Selection 객체 반환
				  logseq.order-list-type:: number
			- 선택하고자 하는 요소가 없을 때:
			  logseq.order-list-type:: number
				- `querySelectorAll()` 실행 → 빈 NodeList 반환
				  logseq.order-list-type:: number
				- `new Selection([])` 생성. 하지만 해당 요소가 존재하지 않으므로 빈 배열로 Selection 객체를 생성한다.
				  logseq.order-list-type:: number
				- Selection 객체 반환
				  logseq.order-list-type:: number
				- 원소를 갖지 않는 빈 Selection 객체를 반환할 수 있기에 D3의 핵심인 **데이터 시각화 요소 생성**을 위한 특수한 초기 단계 역할을 수행할 수 있다.
				  logseq.order-list-type:: number
					- 데이터 바인딩을 위해 selectAll().data().join() 순서로 이어지는 메써드 체이닝의 시작 단계이다.
					  logseq.order-list-type:: number
	- 다음은 두 과정에서 `d3.selectAll()`이 작동하는 순서와 로직을 예시와 함께 정리하면 아래와 같다.
- ## 실행 과정(execution flow)
	- ### 1. 일반적인 DOM 조작 과정 (이미 존재하는 DOM요소를 선택)
		- 이 과정에서 `d3.selectAll()`은 웹 문서(DOM) 내에 **이미 존재하는 다수의 요소**를 선택한다.
		- 후속 메서드로 선택한 요소의 속성, 스타일, 이벤트를 즉시 변경할 수 있다.
			- | 순서 | 작동 로직 | 역할 및 결과 |
			  | **1단계: 선택 (Select)** | `d3.selectAll("selector")`를 호출합니다. 선택자는 CSS 규칙과 동일합니다 (태그, 클래스, ID 등). | **선택자에 일치하는 모든 DOM 요소**를 찾아서 D3 선택 객체로 반환합니다. (예: `<circle>` 요소 3개 모두 선택). |
			  | **2단계: 조작 (Manipulate)** | 반환된 선택 객체에 `.attr()`, `.style()`, `.on()` 등의 메서드를 연결합니다. | 선택된 **모든 요소**에 대해 속성이나 스타일을 즉시 변경하거나 이벤트 리스너를 추가합니다. |
		- #### 예시: 이미 존재하는 모든 원의 색상 변경
			- DOM에 이미 세 개의 `<circle>` 요소가 있을 때, 모든 원의 `fill` 속성을 변경합니다.
			- ```js
			  // 1. 모든 'circle' 요소를 선택합니다. (D3.selectAll()의 기본 용도)
			  d3.selectAll("circle")
			    // 2. 선택된 모든 원의 fill 속성을 'red'로 변경합니다.
			    .attr("fill", "red");
			  ```
	- ### 2. 데이터 바인딩 과정 (존재하지 않는 새 요소 생성)
		- **실제 DOM에 존재하지 않는 요소를 선언적으로 "선택"**한 뒤 해당 Selection 객체를 반환한다. 이 Selection 메서드에 새로운 데이터를 전달해 새로운 하위 요소를 덧붙일 수 있도록 한다.
		- 간단히 말해 D3가 데이터와 DOM을 연결(Data Binding)할 수 있는 연결점을 지시하는 역할을 한다.
		- | 순서 | 작동 로직 | 역할 및 결과 |
		  | **1단계: 빈 선택 생성** | `부모선택.selectAll("새로운요소")`를 호출합니다. | 선택자와 일치하는 요소가 없으므로 **'빈 선택(empty selection)'**을 반환한다. 이 선택은 **새 요소가 삽입될 부모 요소의 참조(컨텍스트)를 유지**한다 [183, 195]. |
		  | **2단계: 데이터 연결** | `.data(myData)` 메서드에 데이터 배열을 전달한다. | D3는 데이터 배열의 크기를 기반으로, 1단계에서 선택된 빈 공간에 **몇 개의 새 요소가 필요한지** 계산한다. |
		  | **3단계: 요소 생성 및 삽입** | `.join("element type")` 메서드를 호출하여 새로운 하위 요소를 DOM에 추가한다. | D3는 2단계에서 결정된 개수만큼 **새 요소(NewElement)**를 생성하고, **1단계에서 지정된 부모 요소의 자식**으로 실제로 삽입한다. 이 과정이 완료되면 `NewElement`가 비로소 DOM에 실제로 존재한다. |
		- #### 예시: 데이터에 따라 막대 그래프 생성
			- SVG 컨테이너(`svg`) 안에 아직 존재하지 않는 `<rect>` 요소들을 데이터(`data`) 개수만큼 생성합니다.
				- ```
				  // data 변수에 33개의 데이터 객체가 있다고 가정
				  svg
				    // 1. 아직 존재하지 않는 <rect> 요소를 선택하여 '빈 선택'을 생성하고, 부모 컨텍스트(svg)를 유지합니다.
				    .selectAll("rect")
				    // 2. 데이터(33개)를 연결하여 33개의 요소가 필요함을 D3에 알립니다.
				    .data(data)
				    // 3. 실제 DOM에 33개의 <rect> 요소를 삽입하고 데이터를 바인딩합니다.
				    .join("rect")
				    .attr("width", d => d.count); // 이후 바인딩된 데이터를 이용해 너비 등을 설정할 수 있습니다.
				  ```
- ### References
	- [Selecting elements | D3 by Observable](https://d3js.org/d3-selection/selecting)
- ### Log
	- [[2025-10-16]] created.