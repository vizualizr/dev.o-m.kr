date-created:: [[2025-10-17]]
date-modified:: [[2025-10-18]] 
division:: [[makr]]
stack:: frontend
tags:: JavaScript, 클로저, 함수, 스코프, class, 개념정리
status:: [[ai-proofed]] 
type::
alias:: javascript/closure

- ## Summary
	- 클로저(closure)란 외부 함수 내에 선언된 지역 변수를, 그 외부 함수가 반환한 **내부 함수**가 계속해서 참조할 수 있는 JavaScript의 핵심 동작 원리(Mechanism)다.
	- 이 원리 덕분에 함수 실행이 끝나도 특정 변수들이 사라지지 않고 유지되어, 결과적으로 **클래스의 인스턴스와 유사하게 비공개 상태(private state)를 갖는 독립적인 객체처럼** 동작하게 만들 수 있다.
	- 즉, 클로저는 &quot;함수가 자신이 선언될 때의 환경(스코프)을 기억하는 것&quot;을 의미한다.
- ## Steps
	- ### **1. 클로저의 정의**
		- 내가 이해한 클로저:
			- 클로저는 중첩된 함수가 상위 함수에 선언된 변수를 처리하는 자바스크립트 고유의 작동 방식이다. 자바스크립트에서 함수를 정의할 때 해당 함수 안에 지역 변수와 이를 참조하는 내부 함수를 함께 선언할 수 있다. 이때 중첩된 함수를 감싸고 있는 함수, 즉 외부 함수를 호출해 새로운 변수에 할당하면 외부 함수에서 선언한 지역 변수가 클래스의 멤버 변수와 동일하게 동작한다.
		- **검토 및 보완:**
			- 위 정의는 클로저로 인해 발생하는 **현상**을 정확하게 설명한다. 여기서 클로저가 발생하는 **구조적 조건**을 추가하면 기술적으로 더 완전한 정의가 된다.
			- **보완된 정의:** 자바스크립트에서 어떤 함수가 지역 변수와 **그 변수를 참조하는 내부 함수**를 함께 정의한다. 선언을 완료한 후 내부 함수를 감싸는 함수(상대적 개념으로 외부함수라 함)가 **내부 함수를 반환**하면, 이 반환된 내부 함수와 그 함수가 기억하는 환경의 조합을 클로저라 한다.
	- ### **2. 클로저의 구조: 외부 함수와 내부 함수**
		- '외부 함수'와 '내부 함수'는 절대적인 개념이 아닌, 두 함수의 포함 관계에 따른 **상대적인 기준**이다.
		- 함수 안에 또 다른 함수가 정의된 구조에서, 감싸고 있는 함수가 **외부 함수**, 그 안에 포함된 함수가 **내부 함수**다.
		- 하나의 함수는 다른 함수에 포함되면 내부 함수가 되고, 동시에 자신이 또 다른 함수를 포함하면 외부 함수의 역할을 할 수도 있다.
		- 외부 함수가 반드시 전역 함수일 필요는 없다.
	- ### **3. 클로저의 정체: 원리 vs 기법**
		- 클로저는 `closure` 같은 키워드로 만드는 문법(Syntax)이나 특정 문제를 해결하는 기법(Technique)이 아니다.
		- 클로저는 JavaScript의 스코프 규칙에 따라 자연스럽게 발생하는 \*\*언어 고유의 동작 원리(Mechanism)이자 특징(Feature)\*\*이다.
		- 개발자는 이 '원리'를 이용하여 '비공개 변수 만들기'나 '상태 유지'와 같은 유용한 프로그래밍 '기법'을 구현한다.
	- ### **4. 클로저와 클래스의 관계**
		- **사용자 시각:**
			- > 클로저는 클래스 개념을 함수 실행에 최적화한 축약형 같다.
		- **검토 및 사실 관계:**
			- 기능적 관점(더 가볍고 함수 중심으로 동일한 목적 달성)에서는 매우 타당한 분석이다.
			- 하지만 **역사적 순서**는 그 반대다.
			- **사실 관계:** 초창기 JavaScript에는 `class`가 없었고, 개발자들은 **생성자 함수(클로저 활용)를 이용해 객체를 만드는 것이 오리지널 방식**이었다.
			- 이후 ES6(2015)에서, 이 방식을 더 편리하고 다른 언어처럼 보이게 만든 **문법적 설탕(Syntactic Sugar)으로 `class` 키워드가 도입**되었다.
	- ## Troubleshooting
		- 클로저는 특별한 문법으로 '선언'하는 것이 아니라, 함수가 중첩되고 내부 함수가 외부 함수의 변수를 참조하는 특정 조건 하에서 자연스럽게 '발생'하는 현상이다.
		- 외부 함수의 실행이 끝나더라도, 클로저(내부 함수)가 참조하고 있는 변수들은 가비지 컬렉터에 의해 수거되지 않고 메모리에 계속 살아남는다.
			- #+BEGIN_TIP
			  왜 closure인가? 무언가 닫힌다는 말인데 대체 뭐가 닫힌다는 말인가?
			  #+END_TIP
			- ```js
			  function createCounter() {
			    let count = 0; // 이 변수는...
			  
			    // ...increment 함수에게는 '자유 변수'입니다.
			    // 왜냐하면 increment 함수 안에서 직접 선언되지 않았기 때문이죠.
			    function increment() {
			      count++;
			      console.log(count);
			    }
			  }
			  const myCounter = createCounter();
			  ```
			- 위 코드에서 `increment()` 가 결과값을 구하려면 외부에 존재하는 변수, count에 의존해야 한다. 따라서 `increment()`는 열린 함수(open function)이다. 외부에서 정의된 변수를 참조해야 값을 구할 수 있기 때문이다. 이때 참조하는 변수를 `자유 변수(Free Variable)`라 한다.
			- 자바스크립트 엔진은 함수 `createCounter()`를 처리하는 과정에서 열려 있는 변수, 즉 자유변수인 `count`가 존재함을 인지한다. 해당 변수를 열린 채로 남겨 두면 외부 요인에 의해 구하고자 하는 값이 달라진다. 따라서 이를 닫힌 상태(closure)로 바꿀 필요가 있다.
			- 즉 `닫음(closure)`은 중첩된 함수가 열린 상태일 때 이를 닫힌 상태로 유지하는 과정이다. 이때 중첩된 함수를 `내부함수`, 내부함수를 둘러싸고 있는 함수는 `외부함수`라 한다.
			- 자바스크립트 엔진은 내부함수가 외부함수에서 선언된 변수에 의존적인지 여부를 실행 전에 이미 인지하고 있다.
			- 외부함수가 호출되는 순간, 내부함수가 참조하는 변수(위에서 `count`)가 내부 함수에 연결된 상태를 유지하도록 묶어두기(bound) 위해 메모리에 해당 변수를 남겨둔다. 이 과정이 클로저(closure, 닫음)이다.
	- ## log
		- [[2025-10-17]] Page created.
		- [[2025-10-18]] Fully understood and paraphrased. ai-proofed
	- ### References
		- [클로저 - JavaScript | MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures)