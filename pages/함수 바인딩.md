date-created:: [[2025-10-17]]
date-modified::
division:: [[makr]]
stack:: frontend
tags:: JavaScript, this, explicit binding, call, apply, bind, 프로그래밍, 개념정리
type::

- ## Summary
	- `call()`, `apply()`, `bind()`는 JavaScript의 모든 함수에서 사용할 수 있는 내장 메서드다.
	- 이 메서드들의 핵심 기능은 함수를 호출할 때 `this`가 참조할 객체를 **명시적으로 지정(바인딩)**하는 것이다.
	- **메서드를 다른 함수의 인자로 전달하면 `this`가 원래 객체와의 연결을 잃어버리는 문제**가 발생한다. [참조](https://ko.javascript.info/bind)
		- ```js
		  let user = {
		    firstName: "John",
		    sayHi() {
		      alert(`Hello, ${this.firstName}!`);
		    }
		  };
		  // user 객체의 메서드를 인수로 사용하면
		  // 해당 객체의 this는 전역객체 windows를 참조한다.
		  setTimeout(user.sayHi, 1000); // Hello, undefined!
		  ```
	- 이를 통해 일반 함수 호출 시 `this`가 전역 객체나 `undefined`를 가리키는 문제를 해결하고, 객체 지향 프로그래밍에서 메서드를 유연하게 빌려 쓰는 등 다양한 활용이 가능하다.
- ## Steps
	- ### **0. 예제 준비**
		- 아래 함수와 객체들을 모든 예제에서 공통으로 사용한다.
		- ```javascript
		  // this의 name과 job을 사용하는 함수
		  function introduce(greeting, closingRemark) {
		    console.log(
		      `${greeting}, 제 이름은 ${this.name}이고, 직업은 ${this.job}입니다. ${closingRemark}`
		    );
		  }
		  
		  // this로 사용될 객체 1
		  const person1 = {
		    name: "김민준",
		    job: "프론트엔드 개발자"
		  };
		  
		  // this로 사용될 객체 2
		  const person2 = {
		    name: "이서연",
		    job: "백엔드 개발자"
		  };
		  ```
	- ### **1. `.call()` - 즉시 호출, 인자는 쉼표로**
		- 함수를 **즉시 호출**하면서, 첫 번째 인자로 전달된 객체를 `this`로 사용하도록 강제한다.
		- 두 번째 인자부터는 호출하는 함수(`introduce`)가 받을 인자들을 쉼표로 구분하여 순서대로 전달한다.
		- **문법:** `func.call(this로_지정할_객체, 인자1, 인자2, ...)`
		- **예시:**
			- ```javascript
			  // introduce 함수의 this를 person1으로 지정하고 즉시 호출한다.
			  introduce.call(person1, "안녕하세요", "잘 부탁드립니다.");
			  // 출력: 안녕하세요, 제 이름은 김민준이고, 직업은 프론트엔드 개발자입니다. 잘 부탁드립니다.
			  
			  introduce.call(person2, "반갑습니다", "만나서 영광입니다.");
			  // 출력: 반갑습니다, 제 이름은 이서연이고, 직업은 백엔드 개발자입니다. 만나서 영광입니다.
			  ```
	- ### **2. `.apply()` - 즉시 호출, 인자는 배열로**
		- `call()`과 기능은 거의 동일하다. 함수를 **즉시 호출**하고 첫 번째 인자로 `this`를 지정한다.
		- 유일한 차이점은 두 번째 인자로 **배열(Array) 또는 유사 배열 객체** 하나만 받는다는 점이다. 이 배열의 요소들이 호출되는 함수의 인자들로 사용된다.
		- **문법:** `func.apply(this로_지정할_객체, [인자1, 인자2, ...])`
		- **예시:**
			- ```javascript
			  const args = ["Hello", "Nice to meet you."];
			  
			  // introduce 함수의 this를 person1으로 지정하고 즉시 호출한다.
			  // args 배열의 요소들이 introduce 함수의 인자로 전달된다.
			  introduce.apply(person1, args);
			  // 출력: Hello, 제 이름은 김민준이고, 직업은 프론트엔드 개발자입니다. Nice to meet you.
			  ```
	- ### **3. `.bind()` - 새로운 함수 반환, 나중에 호출**
		- `call()`, `apply()`와 가장 큰 차이점으로, 함수를 **즉시 호출하지 않는다.**
		- 대신 `this`가 첫 번째 인자로 전달된 객체에 **영구적으로 고정(바인딩)된 새로운 함수를 반환**한다.
		- 이렇게 반환된 함수는 나중에 언제 어디서 호출되든 관계없이 무조건 지정된 `this` 값을 유지한다.
		- **문법:** `const newFunc = func.bind(this로_지정할_객체, 미리_채울_인자1, ...)`
		- **예시:**
			- ```javascript
			  // introduce 함수의 this를 person2에 영구적으로 고정한 새 함수를 만든다.
			  const introducePerson2 = introduce.bind(person2);
			  
			  // 이제 introducePerson2는 언제 호출해도 this가 person2다.
			  introducePerson2("Hi there", "Have a great day!");
			  // 출력: Hi there, 제 이름은 이서연이고, 직업은 백엔드 개발자입니다. Have a great day!
			  
			  // setTimeout과 같은 콜백 함수에서 this를 잃지 않기 위해 매우 유용하다.
			  setTimeout(introduce.bind(person1, "1초 뒤 인사", "시간이 되었습니다."), 1000);
			  ```
- ## Troubleshooting
	- **`.bind()`는 함수를 반환할 뿐, 실행하지 않는다.**
		- `.bind()`를 사용한 후, 반환된 새로운 함수를 다시 `()`로 호출해야 코드가 실행된다. 가장 흔한 실수 중 하나다.
	- **`call()`과 `apply()`의 차이점은 오직 인자를 전달하는 방식뿐이다.**
		- `call()`은 쉼표로 구분된 목록(`arg1, arg2, ...`), `apply()`는 단일 배열(`[arg1, arg2, ...]`).
		- ES6의 전개 연산자(`...`)를 사용하면 `apply()`와 유사한 효과를 `call()`로 낼 수 있다. (예: `introduce.call(person1, ...args)`)
- ## log
	- [[2025-10-17]] Page created.
- ### References
	- [함수 바인딩](https://ko.javascript.info/bind)
	-